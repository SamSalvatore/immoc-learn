[TOC]
# 第7章 Java底层知识：GC相关

##  7-1 垃圾回收之标记算法
对象被判定为垃圾的标准
* 没有被其他对象引用

判定对象是否为垃圾的算法
* 引用计数算法
* 可达性分析算法

引用计数算法
* 通过判断对象的引用数量来决定对象是否可以被回收
* 每个对象实例都有一个引用计数器，被引用则+1，完成引用则-1
* 任何引用计数为0的对象实例可以被当作垃圾收集
* 优点: 执行效率高，程序执行受影响较少
* 缺点: 无法检测出循环引用的情况，导致内存泄漏

可达性分析算法
通过判断对象的引用链是否可达来决定对象是否可以被回收
![-w659](http://it-learn.oss-cn-beijing.aliyuncs.com/2020/04/05/15860542745084.jpg)

可以作为GC Root的对象
* 虚拟机栈中引用的对象
* 方法区中常量引用的对象
* 方法区中静态属性引用的对象
* native方法引用的对象
* 活跃线程引用的对象


##  7-2 Java 垃圾回收之回收算法
### 标记 - 清除算法
* 标记: 从根集合进行扫描，对存活的对象进行标记
* 清除: 对堆内存从头到尾进行线性遍历，回收不可达对象内存
* 会产生大量不连续的内存碎片
![-w1187](http://it-learn.oss-cn-beijing.aliyuncs.com/2020/04/05/15860545276485.jpg)


### 复制算法
* 分为对象面和空闲面
* 对象在对象面上创建
* 存活的对象被从对象面复制到空闲面
* 将对象面所有对象内存清除
* 解决碎片化问题
* 顺序分配内存，简单高效
* 适用于对象存活率低的场景
* 适用于年轻代，每次需要复制的对象都比较少

![-w705](http://it-learn.oss-cn-beijing.aliyuncs.com/2020/04/05/15860547195938.jpg)


### 标记-整理算法
* 标记: 从根集合进行扫描，对存活的对象进行标记
* 清除: 移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收
* 避免内存的不连续性
* 不用设置两块内存互换
* 适用于存活率高的场景
![](http://it-learn.oss-cn-beijing.aliyuncs.com/2020/04/05/15860550378054.jpg)

### 分代收集算法
* 垃圾回收算法的组合拳
* 按照对象生命周期的不同划分区域以采用不同的垃圾回收算法
* 目的: 提高JVM的回收效率

GC的分类
* Minor GC
    * 复制算法
* Full GC
    * 标记-整理
    * 标记-清除

![-w1086](http://it-learn.oss-cn-beijing.aliyuncs.com/2020/04/05/15860586597059.jpg)

###  年轻代: 尽可能快速的回收掉那些生命周期短的对象
* Eden区
* 两个Survivor区
![-w789](http://it-learn.oss-cn-beijing.aliyuncs.com/2020/04/05/15860572641248.jpg)


年轻代垃圾回收过程
1. 首先新对象都被分配到年轻代的Eden空间，如果分配不下的话便会直接分配到老年代，Survivor刚开始是空的。
![](http://it-learn.oss-cn-beijing.aliyuncs.com/2020/04/05/15860590968129.jpg)

2. 当eden区满了之后，便会触发一次minor GC。还被引用的对象被移到第一个 survivor 空间，然后把整个 eden 空间都清理掉。每次进行对象的移动时对象的年龄都会 + 1
![](http://it-learn.oss-cn-beijing.aliyuncs.com/2020/04/05/15860591945719.jpg)

3. 下一次 minor gc 时还是同样的过程，把 eden 中还被引用的对象移到 survivor 空间，然后清除 eden 空间，只是这次是移到第二个 survivor（S1），同时，把上次 minor gc 移到 S0 中的对象也移到 S1，并增加这些对象的年龄，移到 S1 之后，S0 也被清理掉，这时，eden 和 S0 都干净了。

![](http://it-learn.oss-cn-beijing.aliyuncs.com/2020/04/05/15860592816570.jpg)


4. 下一次 minor gc 同理，只是这次换为了 S0，eden 和 S1 都干净了。

![](http://it-learn.oss-cn-beijing.aliyuncs.com/2020/04/05/15860593019783.jpg)

5. 这个过程不断重复，这样 survivor 中对象的年龄会一直增长，当达到一定程度（例如8），这个对象就从年轻代转移到了老年代。
![](http://it-learn.oss-cn-beijing.aliyuncs.com/2020/04/05/15860593215198.jpg)


对象如何晋升到老年代
* 经历一定`Minor`次数依然存活的一项
* Survivor区中存放不下的对象
* 新生成的大对象

常用的调优参数
* -Xms:初始堆大小
* -Xmx：最大堆大小
* -XX:NewSize=n:设置年轻代大小
* -XX:NewRatio=n:设置年轻代和年老代的比值。如：为3表示年轻代和年老代比值为1：3，年轻代占整个年轻代年老代和的1/4
* -XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如3表示Eden： 3 Survivor：2，一个Survivor区占整个年轻代的1/5
* -XX:MaxPermSize=n:设置持久代大小

说明：
* 1、一般初始堆和最大堆设置一样，因为：现在内存不是什么稀缺的资源，但是如果不一样，从初始堆到最大堆的过程会有一定的性能开销，所以一般设置为初始堆和最大堆一样。64位系统理论上可以设置为无限大，但是一般设置为4G,因为如果再大，JVM进行垃圾回收出现的暂停时间会比较长，这样全GC过长，影响JVM对外提供服务，所以不能太大。一般设置为4G。
* 2、-XX:NewRaio和-XX:SurvivorRatio这两个参数，都是设置年轻代和年老代的大小的，设置一个即可，第一是设置年轻代的大小，第二个是设置比值，理论上设置一个既可以满足需求


#### 老年代
老年代：存放生命周期较长的对象
* 标记-清理算法
* 标记-整理算法


![-w789](http://it-learn.oss-cn-beijing.aliyuncs.com/2020/04/05/15860572641248.jpg)

老年代
* Full GC（新生代&老年代） 和 Major GC（老年代，有时候也指整个堆）
* Full GC 比 Minor GC 慢，但执行频率低

触发Full GC的条件
* 老年代空间不足
* 永久代空间不足(JDK8以前)
* Minor GC 晋升到老年代的平均大小大于老年代的剩余空间
* 调用System.gc()


##  7-3 Java垃圾回收之新生代垃圾收集器
### Stop-the-world
* JVM 由于要执行GC而停止了应用程序的执行
* 任何一种GC算法中都会发生
* 多数GC优化通过减少Stop-the-world发生的时间来提高程序性能

### Safepoint
* 分析过程中对象引用关系不会发生变化的点
* 产生Safepoint的地方: 方法调用；循环跳转；异常跳转等


现代的商用虚拟机的都是采用分代收集的，不同的区域用不同的收集器。常用的7种收集器，其适用的范围如图所示
![](http://it-learn.oss-cn-beijing.aliyuncs.com/2020/04/05/15860797572294.jpg)

Serial、ParNew、Parallel Scavenge用于新生代；
CMS、Serial Old、Paralled Old用于老年代。
并且他们相互之间以相对固定的组合使用（具体组合关系如上图）。G1是一个独立的收集器不依赖其他6种收集器。ZGC是目前JDK 11的实验收集器。

### Serial收集器
Serial，是单线程执行垃圾回收的。当需要执行垃圾回收时，程序会暂停一切手上的工作，然后单线程执行垃圾回收。

因为新生代的特点是对象存活率低，所以收集算法用的是复制算法，把新生代存活对象复制到老年代，复制的内容不多，性能较好。
![](http://it-learn.oss-cn-beijing.aliyuncs.com/2020/04/05/15860798513543.jpg)


单线程地好处就是减少上下文切换，减少系统资源的开销。但这种方式的缺点也很明显，在GC的过程中，会暂停程序的执行。若GC不是频繁发生，这或许是一个不错的选择，否则将会影响程序的执行性能。 对于新生代来说，区域比较小，停顿时间短，所以可以使用。

### ParNew收集器
ParNew同样用于新生代，是Serial的多线程版本，并且在参数、算法（同样是复制算法）上也完全和Serial相同。
Par是Parallel的缩写，但它的并行仅仅指的是收集多线程并行，并不是收集和原程序可以并行进行。ParNew也是需要暂停程序一切的工作，然后多线程执行垃圾回收。
![](http://it-learn.oss-cn-beijing.aliyuncs.com/2020/04/05/15860800357056.jpg)

因为是多线程执行，所以在多CPU下，ParNew效果通常会比Serial好。但如果是单CPU则会因为线程的切换，性能反而更差。

### Parallel Scavenge收集器
新生代的收集器，同样用的是复制算法，也是并行多线程收集。与ParNew最大的不同，**它关注的是垃圾回收的吞吐量。** 因此，这种垃圾收集器的GC时间可能很长，只是我们整体系统运行时间也很长。因此，比较适合客户端，不太适合服务端的垃圾收集。


这里的吞吐量指的是 总时间与垃圾回收时间的比例。这个比例越高，证明垃圾回收占整个程序运行的比例越小。这个比例越高，证明垃圾回收占整个程序运行的比例越小。

Parallel Scavenge收集器提供两个参数控制垃圾回收的执行：

* -XX:MaxGCPauseMillis，最大垃圾回收停顿时间。这个参数的原理是空间换时间，收集器会控制新生代的区域大小，从而尽可能保证回收少于这个最大停顿时间。简单的说就是回收的区域越小，那么耗费的时间也越小。 所以这个参数并不是设置得越小越好。设太小的话，新生代空间会太小，从而更频繁的触发GC。
* -XX:GCTimeRatio，垃圾回收时间与总时间占比。这个是吞吐量的倒数，原理和MaxGCPauseMillis相同。

因为Parallel Scavenge收集器关注的是吞吐量，所以当设置好以上参数的时候，同时不想设置各个区域大小（新生代，老年代等）。可以开启**-XX:UseAdaptiveSizePolicy**参数，让JVM监控收集的性能，动态调整这些区域大小参数。



##  7-4 Java垃圾回收之老年垃圾收集器
### Serial Old收集器
老年代的收集器，与Serial一样是单线程，不同的是算法用的是标记-整理（Mark-Compact）
![](http://it-learn.oss-cn-beijing.aliyuncs.com/2020/04/05/15860801873564.jpg)


### Parallel Old收集器
老年代的收集器，是Parallel Scavenge老年代的版本。其中的算法替换成Mark-Compact。
![](http://it-learn.oss-cn-beijing.aliyuncs.com/2020/04/05/15860802692418.jpg)


### CMS收集器
CMS，Concurrent Mark Sweep，同样是老年代的收集器。它关注的是垃圾回收最短的停顿时间（低停顿），在老年代并不频繁GC的场景下，是比较适用的。
命名中用的是concurrent，而不是parallel，说明这个收集器是有与工作执行并发的能力的。MS则说明算法用的是Mark Sweep算法。
来看看具体地工作原理。CMS整个过程比之前的收集器要复杂，整个过程分为四步：

* 初始标记（initial mark），单线程执行，需要“Stop The World”，但仅仅把GC Roots的直接关联可达的对象给标记一下，由于直接关联对象比较小，所以这里的速度非常快。
* 并发标记（concurrent mark），对于初始标记过程所标记的初始标记对象，进行并发追踪标记，此时其他线程仍可以继续工作。此处时间较长，但不停顿。
* 重新标记（remark），在并发标记的过程中，由于可能还会产生新的垃圾，所以此时需要重新标记新产生的垃圾。此处执行并行标记，与用户线程不并发，所以依然是“Stop The World”，时间比初始时间要长一点。
* 并发清除（concurrent sweep），并发清除之前所标记的垃圾。其他用户线程仍可以工作，不需要停顿。
![](http://it-learn.oss-cn-beijing.aliyuncs.com/2020/04/05/15860804452085.jpg)

由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。
由于CMS以上特性，缺点也是比较明显的，
* Mark Sweep算法会导致内存碎片比较多
* CMS的并发能力依赖于CPU资源，所以在CPU数少和CPU资源紧张的情况下，性能较差
* 并发清除阶段，用户线程依然在运行，所以依然会产生新的垃圾，此阶段的垃圾并不会再本次GC中回收，而放到下次。所以GC不能等待内存耗尽的时候才进行GC，这样的话会导致并发清除的时候，用户线程可以利用的空间不足。所以这里会浪费一些内存空间给用户线程预留。

有人会觉得既然Mark Sweep会造成内存碎片，那么为什么不把算法换成Mark Compact呢？
答案其实很简答，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact更适合“Stop the World”这种场景下使用。

### G1收集器（-XX: + UseG1GC, 复制+标记-整理算法）
#### 1. 内存结构
G1首先在内存结构上采用了region化的方法，将堆内存划分成2000块左右的小块，每块大小1-32M（2的幂次），每块region都可以作为E、S、O任意一种，分配灵活，但是存在大对象问题。解决方法是：
* 小于一半region size的可以正常存入E区
* 一半到一个region size的直接存入O区一个region中，这个region又叫Humongous region，我们也可以把它叫做H区（他本质还是O区的）
* 比一个region size还要大的对象，需要存入连续的多个region中，这多个region都是H区。
![](http://it-learn.oss-cn-beijing.aliyuncs.com/2020/04/05/15860849227852.jpg)


这样的分区可以有效避免内存碎片化问题。
但是这样同样会引申一个新的问题，就是分代的内存不连续，导致在GC搜索垃圾对象的时候需要全盘扫描找出引用内存所在。
为了解决这个问题，G1对于每个Region都维护一个Remembered Set，用于记录对象引用的情况。当GC发生的时候根据Remembered Set的引用情况去搜索。


#### 2. 两个概念
* RememberSets，又叫Rsets是每个region中都有的一份存储空间，用于存储本region的对象被其他region对象的引用记录。
* CollectionSets，又叫Csets是一次GC中需要被清理的regions集合，注意G1每次GC不是全部region都参与的，可能只清理少数几个，这几个就被叫做Csets。
![](http://it-learn.oss-cn-beijing.aliyuncs.com/2020/04/05/15860850048146.jpg)

#### 3. YGC
年轻代的GC，StopTheWorld，复制算法。将E和S(from)区复制到S(to)，注意S(to)一开始是没有标识的，就是个free region。下图中没有标出YGC进入老年代的对象，有可能有一部分会进入O区!!
![](http://it-learn.oss-cn-beijing.aliyuncs.com/2020/04/05/15860854007831.jpg)

![](http://it-learn.oss-cn-beijing.aliyuncs.com/2020/04/05/15860854081476.jpg)


#### 4 MixGC 
G1对于老年代的GC比较特殊，本质上**不是只针对老年代，也有部分年轻代**，所以又叫MixGC。


#### 整体的执行流程：
初始标记（initial mark），标记了从GC Root开始直接关联可达的对象。STW（Stop the World）执行。
并发标记（concurrent marking），并发标记初始标记的对象，此时用户线程依然可以执行。
最终标记（Remark），STW，标记再并发标记过程中产生的垃圾。
筛选回收（Live Data Counting And Evacuation），评估标记垃圾，根据GC模式回收垃圾。STW执行。

![](http://it-learn.oss-cn-beijing.aliyuncs.com/2020/04/05/15860855635743.jpg)

在Region层面上，整体的算法偏向于Mark-Compact。因为是Compact，会影响用户线程执行，所以回收阶段需要STW执行。

#### 对比CMS，有哪些不同？
1 region化的内存结构，采用复制清理的方式，避免了内存碎片。但是这种清理也造成了STW。
2 SATB速度更快。
3 初始标记，并发标记，重新标记，清理垃圾四个阶段很像，但是G1中有很多标记region的操作，并借助Rset进行了范围的缩小，提高了并发标记的速度。小结下就是初始标记和YGC的STW一起了，提高了效率；并发标记因为rset的设计，扫描范围缩小了，提高了效率；重新标记因为使用了SATB提高了效率；清理虽然造成了STW，但是复制使内存紧凑，避免了内存碎片。同时只清理垃圾较多的region，最大限度的降低了STW时间。


##  7-5 Java垃圾回收之常见面试题

##  7-6 Java垃圾回收之常见面试题_2
##  7-7 Java垃圾回收之总结
##  7-8 彩蛋之找工作的渠道分析
最为推荐的一种
* 同事朋友的内推
